<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>PathFinder: The Amazing Maze Algorithm Demonstrator!</title>
  <script src='dist/main.js'></script>
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,700" rel="stylesheet">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <style media="screen">
    canvas {
      width: 45%;
      padding: 5px;
      background-color: black;
      cursor: pointer;
    }

    body {
      max-width: 960px;
      margin: 0 auto;
      font-family: 'Roboto', sans-serif;
      padding-bottom: 300px;
    }

    p {
      font-size: 20px;
      width: 536px;
    }

    .enclosure {
      display: flex;
      justify-content: flex-end;
      flex-wrap: wrap;
      padding: 30px;
      width: 70%;
      margin: 0 auto;
    }

    .final-recap canvas {
      width: 30%;
    }

    .canvas-box-wrapper {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: space-between;
      margin-bottom: 25 0px;
      margin-top: 250px;
    }

    .canvas-box-wrapper canvas {
      width: 70%;
      margin-left: 30px;
      margin-top: 20px;
    }

    .maze-double {
      display: flex;
      flex-direction: column;
    }

    .maze-double canvas {
      width: 70%;
    }

    .maze-horiz-double {
      display: flex;
      flex-direction: row;
      justify-content: space-around;
    }

    .maze-horiz-double canvas {
      width: 40%;
      height: 40%;
    }

    .no-top {
      margin-top: 0;
    }

    .caption {
      font-style: italic;
      font-size: 12px;
      margin-left: 30px;
    }
  </style>
</head>

<body style=" background: white;">
  <h1 id="making-mazes">PathFinder: Algorithms for Making and Solving Mazes</h1>
  <h3 id="making-mazes">An interactive demo by Elliot Milco</h3>
  <p><em>Click any box to run that demo again.</em></p>
  <div class="canvas-box-wrapper">
    <div class="left-text">

      <h2 id="spanning-trees-and-maze-design">Spanning Trees and Maze Design</h2>

      <p>What makes a maze a maze? How would you go about building one?</p>

      <p>Mazes are designed to thwart our best intuitions about how to get from one place to another. In a well-designed maze, there is no straight path to the goal, and there are many dead ends along the way.</p>

      <p>Making a good maze requires a heavy dose of randomness. We want walls and paths to appear without any apparent order. But we do need there to be <em>some</em> order, otherwise the maze would be insoluble.</p>


    </div>
    <div>
      <canvas id="0" width="495px" height="495px"></canvas>
      <p class="caption">A* Search solving a maze generated using Prim's Algorithm.</p>
    </div>

  </div>

  <div class="canvas-box-wrapper">

    <div class="left-text">

      <p>One way to provide the minimum necessary connectedness to create a good maze is to build the maze as a spanning tree.</p>

      <p>A <strong>spanning tree</strong> is a kind of network. It follows two simple rules: (1) Every available point must be connected to the network, and (2) no point can be connected to itself. Total coverage, no cycles.</p>

      <p>There are many ways to generate spanning trees. Since points in a two-dimensional plane each have four neighbors, the easiest way for us will be to radiate outward from the start of the maze, connecting each point to all of its unconnected neighbors,
        until the whole space is full.</p>

      <p>This produces a pretty boring maze. How can we do better?</p>
    </div>

    <div>
      <!-- BFS non-maze, B&W -->
      <canvas id="1" width="495px" height="495px"></canvas>
      <p class="caption">Our simplest maze.</p>
    </div>
  </div>

  <div class="canvas-box-wrapper">


    <div class="left-text">

      <h2 id="randomized-growth">Randomized Growth</h2>
      <p>There are many ways to inject randomness into spanning tree generation. Here's the simplest way, represented as an algorithm:</p>

      <ol style="list-style-type: decimal">
        <li>Keep a list of possible path extensions, starting with just the entry point.</li>
        <li>Pick a <strong>random element</strong> out of the list.</li>
        <li>Will adding that point to the maze cause the maze to intersect itself?</li>
        <li>If not, add that point to the maze, and add all of its unvisited neighbors to the list of possible path extensions.</li>
        <li>Either way, mark that point as visited.</li>
        <li>Repeat until the list is empty.</li>
      </ol>

      <p>This approach produces mazes like the one seen here.</p>

      <p>The maze grows evenly and organically to fill the space. Each next path extension may be randomly chosen, but in any given round, all the available extensions have the same chance of being chosen. This way of structuring our randomness produces
        locally unpredictable, but globally regular behavior.</p>

    </div>
    <div>
      <!-- BFS maze, B&W -->
      <canvas id="2" width="495px" height="495px"></canvas>
      <p class="caption">A randomized growth maze, similar to BFS.</p>
    </div>
  </div>

  <div class="canvas-box-wrapper">

    <div class="left-text">

      <p>If we color the maze based on the path-distance of each segment from the starting point (&quot;the root&quot;), we can get a decent sense of the global structure of the maze:</p>

      <p>Notice how the color gradient shifts evenly from the top left corner (the root), outward. This tells us that there aren't any crazy backtracking paths in the maze. But what if we wanted a maze that was more chaotic?</p>

    </div>
    <div>
      <!-- BFS maze, Colored -->
      <canvas id="3" width="495px" height="495px"></canvas>
      <p class="caption">A randomized growth maze, colored by path-distance from the root.</p>
    </div>
  </div>





  <div class="canvas-box-wrapper">


    <div class="left-text">


      <h2 id="weighted-randomness-prims-algorithm">Weighted Randomness &amp; Prim's Algorithm</h2>

      <p>In our simple randomized growth algorithm, we used random selection from the set of candidate extensions to grow the maze. Because every node had a fresh chance in every drawing, the overall tendency was toward unbiased radial expansion outward from the root.</p>

      <p>We want to put the randomness into the <em>global structure</em> instead of just the local path expansion. We can do this by assigning every square on the grid a random weight, and then using Prim's algorithm to build our maze.</p>

      <p><strong>Prim's algorithm</strong> is a method for building a minimum spanning tree. A minimum spanning tree is a spanning tree that's designed to choose the <em>least expensive</em> way of connecting all the tree's nodes, based on the cost of drawing any particular connection.</p> <p>Prim's accomplishes this by choosing the least expensive path extension at each cycle. Because each node has a fixed weight, if a node is generated with a high weight, it will be selected against in every successive round until it is the least expensive remaining node.</p>

      <p>For the most part, Prim's algorithm is identical to our earlier algorithm. We add an initial step before our old step 1,</p>

      <ol start="0" style="list-style-type: decimal">
        <li>First, assign every potential square a random numerical weight.</li>
      </ol>

      <p>and we change step 2,</p>

      <ol start="2" style="list-style-type: decimal">
        <li>Pick the <strong>least expensive element</strong> out of the list.</li>
      </ol>

      <p>This approach produces mazes like the one seen here.</p>
    </div>
    <div>
      <!-- Prim's maze, B&W -->
      <canvas id="4" width="495px" height="995px"></canvas>
      <p class="caption">A maze generated using randomized weight-assignment and Prim's algorithm.</p>
    </div>
  </div>

  <div class="canvas-box-wrapper">

    <div class="left-text">

      <p>Let's color it to get a better sense of the global structure. Notice that the randomized Prim's maze is much more complex, but that the local structure remains random. </p>

      <p>This maze also constitutes a <em>good</em> maze from a straightforward design perspective: there are long, complex, blind alleys, and the path-distance of any given node is not easily predicted based on its position in the grid.</p>
    </div>
    <div>
      <!-- Prim's maze, Colored -->
      <canvas id="5" width="495px" height="495px"></canvas>
      <p class="caption">A maze generated with Prim's algorithm, colored by path-distance from the root.</p>
    </div>
  </div>

  <div class="canvas-box-wrapper">



    <div class="left-text">
      <h2 id="restricted-randomness-depth-first-growth">Restricted Randomness &amp; Depth First Growth</h2>

      <p>Before solving our mazes, let's try out one more generator. Suppose we wanted mazes with extremely deep, winding paths. How would we change our path-extension algorithm to produce that?</p>

      <p>One way to create deep mazes is based on <strong>depth first search</strong> (DFS), a tree-searching algorithm. DFS sets its search trajectory to prioritize the current branch. In other words, it tries to keep going along a particular path as far as
        possible before exploring other, earlier options.</p>

      <p>A non-randomized depth-first growth maze looks like this:</p>
    </div>
    <div>
      <!-- DFS non-maze, B&W -->
      <canvas id="6" width="495px" height="495px"></canvas>
      <p class="caption">Our simplest depth-first maze.</p>
    </div>
  </div>



  <div class="canvas-box-wrapper">

    <div class="left-text">
      <p>In order to give our DFS maze some complexity, we choose randomly from the N most recently added elements in our list of possible path extensions.</p>
      <p>Let's set N to 4, since any given node can have at most four valid unincorporated neighbor nodes. And here's our maze:</p>
    </div>
    <div>
      <!-- DFS maze, B&W -->
      <canvas id="7" width="495px" height="495px"></canvas>
      <p class="caption">A randomized depth-first maze.</p>
    </div>
  </div>


  <div class="canvas-box-wrapper">

    <div class="left-text">
      <p>When we colorize the DFS maze, its global structure becomes clear. Compare a DFS maze, top, with our initial random-growth maze, bottom. Notice how many times our DFS maze cycles through the color spectrum before it fills the space.</p>
      <p>Depth first mazes can be as much as ten-times deeper than a random growth maze of the same size.</p>
      <p>However, there's a big downside to our DFS maze. Because DFS is biased in favor of extending the current branch of the tree, our maze ends up dominated by a couple of very long, locally simple corridors.</p>
      <p>A we will see below, the solution to a DFS maze may be very convoluted, but it's often not hard to find.</p>

      <p>Speaking of solving mazes, let's do some of that!</p>
    </div>
    <div class="maze-double">
      <div>
        <!-- DFS maze, Colorized -->
        <canvas id="8" width="495px" height="495px"></canvas>
        <p class="caption">Depth-first maze, colored by path distance from the root.</p>
      </div>

      <div>
        <!-- BFS maze, Colorized -->
        <canvas id="9" width="495px" height="495px"></canvas>
        <p class="caption">Random expansion (breadth-first) maze, colored by path distance from the root.</p>
      </div>
    </div>
  </div>




    <div class="canvas-box-wrapper">



      <div class="left-text">
        <h1 id="maze-solvers">Maze Solvers</h1>


        <h2 id="depth-first-search">Depth First Search</h2>

        <p>Depth First Search is a simple algorithm for finding the path to a target node in a tree, given a starting point. DFS uses a stack to maintain a list of nodes to explore.</p>

        <ol style="list-style-type: decimal">
          <li>Start at the root.</li>
          <li>Pop the last (i.e. most recently added) element off the stack.</li>
          <li>Check for a match. If found, return the target node.</li>
          <li>Add each of the current node's children to the stack.</li>
          <li>Repeat until a match is found, or the stack is empty.</li>
        </ol>

        <p>The result is a search path that goes as deep as possible down a single branch before trying another branch. </p>
        <p>To the right you can see DFS solving each of our three maze types. Whenever a given path segment is explored, the search algorithm colors it white to show where it's been.</p>
        <p>I have placed the root of each maze in the exact center to better show the behavior of the algorithm.</p>
      </div>
      <div class="maze-double">
        <div>
          <!-- BFS maze, with DFS solver, root at center -->
          <canvas id="10" width="495px" height="495px"></canvas>
          <p class="caption">Breadth-first maze, solved by Depth First Search, root at center</p>
        </div>
        <div>
          <!-- Prim's maze, with DFS solver, root at center -->
          <canvas id="11" width="495px" height="495px"></canvas>
          <p class="caption">Prim's maze, solved by Depth First Search, root at center</p>
        </div>
        <div>
          <!-- DFS maze, with DFS solver, root at center -->
          <canvas id="12" width="495px" height="495px"></canvas>
          <p class="caption">Depth-first maze, solved by Depth First Search, root at center</p>
        </div>
      </div>

    </div>

    <div class="canvas-box-wrapper">

      <div class="left-text">
        <h2 id="breadth-first-search">Breadth First Search</h2>

        <p>Breadth First Search is similar to DFS, but it treats the list of nodes to search as a queue instead of a stack. In other words, step 2 of the algorithm listed above becomes:</p>

        <ol start="2" style="list-style-type: decimal">
          <li>Shift the first (i.e. least recently added) element out of the queue.</li>
        </ol>

        <p>The result is the smooth radial expansion you see here.</p>
      </div>
      <div>
        <!-- BFS maze, BFS Solver, Root at center -->
        <canvas id="13" width="495px" height="495px"></canvas>
        <p class="caption">BFS solving a random expansion (breadth-first) maze, root at center.</p>
      </div>
    </div>





    <div class="canvas-box-wrapper">
      <div class="left-text">
        <p>Comparing BFS to DFS, we see that BFS is potentially much more expensive in terms of the number of nodes explored before finding the solution. This depends in part on the relative position of root and target within the maze.</p>
        <p>If the path distance between root and target is small relative to the size of the maze, BFS (top) will tend to outperform DFS (bottom).</p>
      </div>
      <div class="maze-double">
        <div>
          <!-- Prim's maze, BFS Solver, Root and Target near center -->
          <canvas id="14" width="495px" height="495px"></canvas>
          <p class="caption">BFS solving a Prim's maze, with root and target near center.</p>
        </div>
        <div>
          <!-- Prim's maze, DFS Solver, Root and Target near center -->
          <canvas id="15" width="495px" height="495px"></canvas>
          <p class="caption">DFS solving a Prim's maze, with root and target near center.</p>
        </div>
      </div>
    </div>




  <div class="canvas-box-wrapper">

    <div class="left-text">
      <p>Both methods have their weak spots, though. On the other hand, if the root and target are maximally distant from each other within the maze, BFS will have to explore the entire tree before finding the goal, while DFS goes straight for the fringes.</p>
    </div>
    <div>
      <!-- BFS maze, DFS Solver, Root at corner -->
      <canvas id="16" width="495px" height="495px"></canvas>
      <p class="caption">DFS solving a random-growth maze, maximum distance between root and target.</p>
    </div>
  </div>




  <div class="canvas-box-wrapper">
    <div class='left-text'>
    <h2 id="dijkstras-algorithm">Dijkstra's Algorithm</h2>

    <p>DFS and BFS are cool, and they're both guaranteed to find solutions under normal conditions (e.g. provided our maze is finite and our target is reachable). But they're not very smart. As we've seen above, both algorithms are agnostic about the structure
      of the maze and the probability of success searching along any given trajectory. We can do better!</p>

    <p>When we wanted to improve the structure of our generated maze, we used randomized weighting and Prim's algorithm. In order to build a smart maze solver, we're going to take a similar approach. In this case we will use a heuristic-guided improvement
      on Dijkstra's algorithm called A* (&quot;A-Star&quot;).</p>

    <p><strong>Dijkstra's Algorithm</strong> is a path-finding method that prioritizes the least-expensive available node in our search queue. Typically we implement this using a <strong>min-heap priority queue</strong>, which is a <em>very speedy</em> data
      structure for maintaining a list in which the first element is guaranteed to have the minimum value in the entire list. (Note, our implementation of Prim's above uses a priority queue like this too!)</p>
    </div>
  </div>



  <div class="canvas-box-wrapper no-top">

    <div class="left-text">
      <p>Dijkstra's proceeds like BFS, with changes to step 2:</p>

      <ul start="2" style="list-style-type: decimal">
        <li>Remove the minimum entry from the priority queue.</li>
      </ul>

      <p>and step 4:</p>

      <ul start="4" style="list-style-type: decimal">
        <li>Insert each of the current node's children into the priority queue.</li>
      </ul>
      <p>So far so good. The only problem is that, because in reality our maze is an <em>unweighted</em> graph, there's actually no difference between the cost of exploring any one node and exploring any other. That means that our priority queue will honor a First-In, First-Out (FIFO) ordering principle, making Dijkstra's algorithm identical in execution to .... Breadth First Search. Behold:</p>

      <p>So much for doing better!</p>
    </div>
    <div>
      <!-- BFS maze, Dijkstra solver -->
      <canvas id="17" width="495px" height="495px"></canvas>
      <p class="caption">Dijkstra's algorithm solving a random-growth maze. Looks a lot like BFS!</p>
    </div>


  </div>


  <div class="canvas-box-wrapper">

    <div class="left-text">
      <h2 id="a-search">A* Search</h2>

      <p>Now that we've built out a Dijkstra maze solver, though, we can use it to implement an intuition-based path-finding-algorithm called A*.</p>

      <p>A* keeps track of two different factors. First, how expensive it was to get to a given node from the origin. Second, the minimum predicted cost of getting from that node to the goal. A* predicts the cost of traveling through a given node based on a
        heuristic function we provide it, which is based on the structure of our graph.</p>

      <p>In this case, we set the heuristic function to calculate the diagonal distance between the current node and the target node, so that our search will be encouraged to go as directly toward the goal as possible.</p>

      <p>How does A* perform? You can see it in action on the right.</p>

      <p>As with DFS I have placed the root of the maze at the center, to better illustrate the behavior of the algorithm.</p>

      <p>You can see that when a relatively direct path is available, A* tends to find it, and quickly. A* also has an advantage when the root and target are close together, relative to the size of the graph.</p>

      <p>A* doesn't always outperform DFS (or even BFSâ€”intuition can lead us astray!), but it is about as good in the worst case, and better on average.</p>
    </div>

    <div class="maze-double">
      <div>
        <!-- BFS maze, A* solver, Root at center -->
        <canvas id="18" width="495px" height="495px"></canvas>
        <p class="caption">A* solving a random-growth maze, root at center.</p>
      </div>
      <div>
        <!-- Prim's maze, A* solver, Root at center -->
        <canvas id="19" width="495px" height="495px"></canvas>
        <p class="caption">A* solving a Prim's maze, root at center.</p>
      </div>
      <div>
        <!-- DFS maze, A* solver, Root at center -->
        <canvas id="20" width="495px" height="495px"></canvas>
        <p class="caption">A* solving a depth-first maze, root at center.</p>
      </div>
    </div>
  </div>






  <p>Finally, to sum up, you can see all three of our solvers solving all three of our mazes at once!</p>
  <div class="final-recap">
    <canvas id="21" width="495px" height="495px"></canvas>
    <canvas id="22" width="495px" height="495px"></canvas>
    <canvas id="23" width="495px" height="495px"></canvas>
    <canvas id="24" width="495px" height="495px"></canvas>
    <canvas id="25" width="495px" height="495px"></canvas>
    <canvas id="26" width="495px" height="495px"></canvas>
    <canvas id="27" width="495px" height="495px"></canvas>
    <canvas id="28" width="495px" height="495px"></canvas>
    <canvas id="29" width="495px" height="495px"></canvas>
  </div>

</body>

</html>
